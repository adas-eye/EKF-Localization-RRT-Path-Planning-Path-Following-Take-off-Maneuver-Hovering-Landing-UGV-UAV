function sysCall_init()
    -- Detatch the manipulation sphere:
    targetObj=sim.getObjectHandle('Quadricopter_target')
    sim.setObjectParent(targetObj,-1,true)

    -- This control algo was quickly written and is dirty and not optimal. It just serves as a SIMPLE example

    baseHandle=sim.getObjectHandle('Quadricopter_base')
    awalPos = sim.getObjectPosition(baseHandle, -1)
    -- PengenPos = {5.5249e-01,8.0465e-01,3.3601e-01} 
    
   NodePos = {{1.5126e+00, -1.5048e+00, 1.4600e+00},
              {1.6376e+00, 1.0702e+00, 1.4600e+00},
              {-1.5374e+00, -4.7792e-03, 1.4600e+00}}
    
    stateNow = 0
    nextstate = 1
    Dx = NodePos[nextstate][1] - awalPos[1]
    Dy = NodePos[nextstate][2] - awalPos[2]
   
    stepXY = 100.0
    stepZ = 20
    
    dx = Dx/stepXY
    dy = Dy/stepXY
   
    cusPos = awalPos
    
    propellerScripts={-1,-1,-1,-1}
    for i=1,4,1 do
        propellerScripts[i]=sim.getScriptHandle('Quadricopter_propeller_respondable'..i)
    end
    heli=sim.getObjectAssociatedWithScript(sim.handle_self)
    particlesTargetVelocities={0,0,0,0}

    pParam=2
    iParam=0
    dParam=0
    vParam=-2

    cumul=0
    lastE=0
    pAlphaE=0
    pBetaE=0
    psp2=0
    psp1=0

    prevEuler=0
end

function sysCall_actuation()

    s=sim.getObjectSizeFactor(baseHandle)
   
    pos=sim.getObjectPosition(baseHandle,-1)
   
    -- Vertical control:
    targetPos=sim.getObjectPosition(targetObj,-1)
    pos=sim.getObjectPosition(baseHandle,-1)
    l=sim.getVelocity(heli)
    e=(targetPos[3]-pos[3])
    cumul=cumul+e
    pv=pParam*e
    thrust=5.335+pv+iParam*cumul+dParam*(e-lastE)+l[3]*vParam
    lastE=e

    if (math.abs(e) < 0.01) and udah_sampai_xy then
        cusPos[3] = cusPos[3] + dz
        sim.setObjectPosition(targetObj, -1, cusPos)
    end
    
    -- Horizontal control:
    sp=sim.getObjectPosition(targetObj,baseHandle)
    m=sim.getObjectMatrix(baseHandle,-1)
    vx={1,0,0}
    vx=sim.multiplyVector(m,vx)
    vy={0,1,0}
    vy=sim.multiplyVector(m,vy)
    alphaE=(vy[3]-m[12])
    alphaCorr=0.25*alphaE+2.1*(alphaE-pAlphaE)
    betaE=(vx[3]-m[12])
    betaCorr=-0.25*betaE-2.1*(betaE-pBetaE)
    pAlphaE=alphaE
    pBetaE=betaE
    alphaCorr=alphaCorr+sp[2]*0.005+1*(sp[2]-psp2)
    betaCorr=betaCorr-sp[1]*0.005-1*(sp[1]-psp1)
    psp2=sp[2]
    psp1=sp[1]
   
    posTargetNow=sim.getObjectPosition(targetObj,-1)
    dxn = posTargetNow[1] - NodePos[nextstate][1]
    dyn = posTargetNow[2] - NodePos[nextstate][2]
   
    if (math.sqrt(dxn^2 + dyn^2) <= 0.01) then
        if(nextstate < 3) then
           nextstate = nextstate + 1
        else
           nextstate = 0
        end
        
        if(stateNow < 3) then
           stateNow = stateNow + 1
        else
           stateNow = 0
        end
       
       awalPos = posTargetNow
       Dx = NodePos[nextstate][1] - awalPos[1]
       Dy = NodePos[nextstate][2] - awalPos[2]
       
       dx = Dx/stepXY
       dy = Dy/stepXY
       
       cusPos = awalPos
    end
    
    if (math.sqrt(alphaE^2 + betaE^2) < 0.01) and not(udah_sampai_xy) then
        cusPos[1] = cusPos[1] + dx
        cusPos[2] = cusPos[2] + dy
        sim.setObjectPosition(targetObj, -1, cusPos)
    end
   
    -- Rotational control:
    euler=sim.getObjectOrientation(baseHandle,targetObj)
    rotCorr=euler[3]*0.1+2*(euler[3]-prevEuler)
    prevEuler=euler[3]
   
    -- Decide of the motor velocities:
    particlesTargetVelocities[1]=thrust*(1-alphaCorr+betaCorr+rotCorr)
    particlesTargetVelocities[2]=thrust*(1-alphaCorr-betaCorr-rotCorr)
    particlesTargetVelocities[3]=thrust*(1+alphaCorr-betaCorr+rotCorr)
    particlesTargetVelocities[4]=thrust*(1+alphaCorr+betaCorr-rotCorr)
   
    -- Send the desired motor velocities to the 4 rotors:
    for i=1,4,1 do
        sim.setScriptSimulationParameter(propellerScripts[i],'particleVelocity',particlesTargetVelocities[i])
    end
end 

